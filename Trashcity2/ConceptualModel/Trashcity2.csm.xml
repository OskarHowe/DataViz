<?xml version="1.0" encoding="UTF-8"?>
<!--
  Language: XML
  $Author:$
  $Date:$
  $Revision$
  $Copyright: [2010-2017] Cosmo Tech, All Rights Reserved $
-->
<csm:Model xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:doc="http://www.cosmotech.com/csm_doc/8.8" xmlns:dbk="http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" xmlns:csm="http://www.cosmotech.com/csm/8.8">
  <csm:ModelName>Trashcity2</csm:ModelName>
  <csm:DataType xsi:type="csm:BoolType" name="Boolean"/>
  <csm:DataType xsi:type="csm:IntType" name="Integer" bits="32" signed="1"/>
  <csm:DataType xsi:type="csm:FloatType" name="FloatingPoint" bits="32"/>
  <csm:DataType xsi:type="csm:StringType" name="String"/>
  <csm:BasicEntity name="Inhabitant">
    <csm:Rule name="Perceive">
      <csm:CPPCode><![CDATA[int manif = 0;
int count = 0;
// iterate over calling entity neighbors and sum their satisfaction values
csmForEachTypedNeighbor(BE_Inhabitant, neighbor){
  if(neighbor->GetComState(this)){ // call the neighbor communicator
    manif++;
  }
  count++;
}
int avrg = float(manif) / float(std::max(count, 1));
if(avrg > 0.2){
    SetSurroundingManif(true);
}
else{
    SetSurroundingManif(false);
}]]></csm:CPPCode>
      <csm:EnvironmentReference>Quartier</csm:EnvironmentReference>
    </csm:Rule>
    <csm:Rule name="React">
      <csm:CPPCode><![CDATA[int aggr = GetAgression();
if ((aggr > 1/2 * GetMentality() )&& GetSurroundingManif()) {
  SetManifestation(true);
}]]></csm:CPPCode>
      <csm:EnvironmentReference>Quartier</csm:EnvironmentReference>
    </csm:Rule>
    <csm:Process name="ProduceTrash">
      <csm:CPPCode><![CDATA[// Generate a the probablity to pruduce trash between 1 and 10
int prob = rand()%9 + 1;
int newTrash = 0;
// calculate amount satisfaction is trashproduction
int burnedBins = 1;
if(GetManifestation()){
    newTrash =1/10* pow(GetAgression(), 2) + GetTrashproduction() + burnedBins;
}else{ //stack trash at home
    newTrash = GetTrashproduction();
}
if (prob > 6){ // probablity to deposit
    SetBin(GetBin() + newTrash + GetTrashStack()); //empty homebin into big bin
    SetTrashStack(0); //home bin is empty
}
else{ //stack trash at home
    SetTrashStack(newTrash + GetTrashStack());
}]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="UpdateSatisfaction">
      <csm:CPPCode><![CDATA[int threshold = 14 * GetTrashproduction(); //in g trash has not been picked up since 14 days
if(GetBin() > threshold){
  SetAgression(std::min(21, int(GetAgression() + 1)));
  if(GetAgression() > GetMentality()){
      SetManifestation(true);
  }
  else{
    SetManifestation(false);
  }
}
else{
  SetAgression(std::max(1, int(GetAgression() - 5)));
    if(GetAgression() > GetMentality()){
      SetManifestation(true);
  }
  else{
    SetManifestation(false);
  }
}]]></csm:CPPCode>
    </csm:Process>
    <csm:State xsi:type="csm:CompositeType" name="InhabitantState">
      <csm:Container>
        <csm:Attribute name="Agression" modifier="Variable">
          <csm:Documentation>value betaeen -1 and 1</csm:Documentation>
          <csm:DataType xsi:type="csm:FloatType" name="Float" bits="32"/>
          <csm:DefaultValue>1</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Trashproduction" modifier="Parameter">
          <csm:DataType xsi:type="csm:IntType" name="Int" bits="32" signed="1"/>
          <csm:DefaultValue>2</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Bin" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_1" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="TrashStack" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_5" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Manifestation" modifier="Variable">
          <csm:DataType xsi:type="csm:BoolType" name="Bool"/>
          <csm:DefaultValue>false</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Mentality" modifier="Parameter">
          <csm:Documentation>defines at which agressivity level people start demonstrations</csm:Documentation>
          <csm:DataType xsi:type="csm:IntType" name="Int_8" bits="32" signed="1"/>
          <csm:DefaultValue>8</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="SurroundingManif" modifier="Variable">
          <csm:DataType xsi:type="csm:BoolType" name="Bool_2"/>
          <csm:DefaultValue>false</csm:DefaultValue>
        </csm:Attribute>
      </csm:Container>
    </csm:State>
  </csm:BasicEntity>
  <csm:BasicEntity name="Truck">
    <csm:Rule name="PickupTrash">
      <csm:CPPCode><![CDATA[
int bin = 0;
int spaceLeft = 0;
if(GetActive()){
    int ran = rand()%52 + 1;

    if(ran > GetMalfunctionPerYear()){
      int NbInhabitants = 0;
      csmForEachTypedNeighbor(BE_Inhabitant, neighbor){
          NbInhabitants++;
      }
      std::vector<BE_Inhabitant*> neighbors;
      neighbors.reserve(NbInhabitants);
      csmForEachTypedNeighbor(BE_Inhabitant, neighbor){
          //put into array and shuffle
          neighbors.push_back(neighbor);
      }
      std::random_device rd;
      std::mt19937 g(rd());
      std::shuffle(neighbors.begin(), neighbors.end(), g);
      std::vector<BE_Inhabitant*>::iterator iter;
      for(iter = neighbors.begin(); iter != neighbors.end(); iter++){
        bin = (*iter)->GetComState(this); // call the neighbor communicator
        spaceLeft = GetVolume() - GetFullness();
          if(0 > spaceLeft){
          spaceLeft = 0;
        }
        if((spaceLeft - bin) >= 0){
          SetFullness(GetFullness()+bin);
          (*iter)->SetBin(0);
        }
        else{
          SetFullness(GetFullness()+spaceLeft);
          (*iter)->SetBin(bin-spaceLeft);
        }
      }
    }
  }
]]></csm:CPPCode>
      <csm:EnvironmentReference>Quartier</csm:EnvironmentReference>
    </csm:Rule>
    <csm:Process name="CalcCost">
      <csm:CPPCode><![CDATA[
float volume = GetVolume();
float cost = pow(volume/200 -11.35, 4) + 1.5*GetBaseCost();

if(GetActive()){
    SetCostPerRoute(cost);
  //SetCostPerRoute(50);
}
else{
    SetCostPerRoute(GetBaseCost() + log(volume));
    //SetCostPerRoute(0);
}
//https://www.desmos.com/calculator?lang=fr
//\left(\frac{x}{200}-d\right)^{3}+1.5p
]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="EmptyLoad">
      <csm:CPPCode><![CDATA[if(GetActive()){
    SetLastFullness(GetFullness());
}
else{
    SetLastFullness(0);
}
SetFullness(0);]]></csm:CPPCode>
    </csm:Process>
    <csm:State xsi:type="csm:CompositeType" name="TruckState">
      <csm:Container>
        <csm:Attribute name="Volume" modifier="Parameter">
          <csm:DataType xsi:type="csm:IntType" name="Int_3" bits="32" signed="1"/>
          <csm:DefaultValue>3500</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Fullness" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_4" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="CostPerRoute" modifier="Variable">
          <csm:DataType xsi:type="csm:FloatType" name="Float_2" bits="32"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="Active" modifier="Variable">
          <csm:DataType xsi:type="csm:BoolType" name="Bool_3"/>
          <csm:DefaultValue>false</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="BaseCost" modifier="Parameter">
          <csm:DataType xsi:type="csm:FloatType" name="Float_5" bits="32"/>
          <csm:DefaultValue>300.0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="MalfunctionPerYear" modifier="Parameter">
          <csm:DataType xsi:type="csm:IntType" name="Int_9" bits="32" signed="1"/>
          <csm:DefaultValue>7</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="LastFullness" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_11" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
      </csm:Container>
    </csm:State>
  </csm:BasicEntity>
  <csm:CompoundEntity name="City">
    <csm:MesoFunction name="Overview">
      <csm:CPPCode><![CDATA[]]></csm:CPPCode>
      <csm:Operations>
        <csm:Operation xsi:type="csm:MesoSum" target="TotalTrash" subEntityAttribute="TotalTrash"/>
        <csm:Operation xsi:type="csm:MesoSum" target="TotalCost" subEntityAttribute="TruckCostTotal"/>
        <csm:Operation xsi:type="csm:MesoTypeCount" target="NbStreets" subEntityType="Street"/>
        <csm:Operation xsi:type="csm:MesoValueCount" target="NbManifestation" subEntityAttribute="HasManifestationStreet" attributeValue="true"/>
      </csm:Operations>
    </csm:MesoFunction>
    <csm:MesoState xsi:type="csm:CompositeType" name="CityMesoState">
      <csm:Container>
        <csm:Attribute name="TotalTrash" modifier="Variable">
          <csm:DataTypeReference>Integer</csm:DataTypeReference>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="TotalCost" modifier="Variable">
          <csm:DataTypeReference>FloatingPoint</csm:DataTypeReference>
        </csm:Attribute>
        <csm:Attribute name="NbManifestation" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_7" bits="32" signed="1"/>
        </csm:Attribute>
        <csm:Attribute name="NbStreets" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_6" bits="32" signed="1"/>
        </csm:Attribute>
      </csm:Container>
    </csm:MesoState>
    <csm:Compound>
      <csm:Environment>NoEnvironment</csm:Environment>
      <csm:SubEntities>
        <csm:CanBeWithin>Street</csm:CanBeWithin>
      </csm:SubEntities>
    </csm:Compound>
  </csm:CompoundEntity>
  <csm:CompoundEntity name="Street">
    <csm:Process name="CalcTrucksNeededAndActivate1">
      <csm:CPPCode><![CDATA[
int activeTrucks = GetActiveTrucks();
int totalTrash = GetTotalTrash();
int inhabitants = GetNbInhabitants();

if((totalTrash/inhabitants > GetTresholdTotalTrashPerInhab()) && (activeTrucks < GetNbTrucks())){
    activeTrucks++;
    SetActiveTrucks(activeTrucks);
    SetActiveTrucksNeeded(activeTrucks);
    csmForEachTypedSubEntity(BE_Truck, truck){
        truck->SetActive(false);
    }

    csmForEachTypedSubEntity(BE_Truck, truck){
        if(activeTrucks > 0){
            truck->SetActive(true);
            activeTrucks--;
        }
    }
}
else if((totalTrash/inhabitants > GetTresholdTotalTrashPerInhab()) && (activeTrucks >= GetNbTrucks())){
    SetActiveTrucksNeeded(GetActiveTrucks() + 1);
}
else if((totalTrash/inhabitants < GetTresholdTotalTrashPerInhab()) && (activeTrucks > 0)){
  activeTrucks--;
    SetActiveTrucks(activeTrucks);
  SetActiveTrucksNeeded(activeTrucks);
    csmForEachTypedSubEntity(BE_Truck, truck){
        truck->SetActive(false);
    }

    csmForEachTypedSubEntity(BE_Truck, truck){
        if(activeTrucks > 0){
            truck->SetActive(true);
            activeTrucks--;
        }
    }
}
]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="CalManif">
      <csm:CPPCode><![CDATA[
int NbInhabs = 0;
int NbManifesting = 0;
csmForEachTypedSubEntity(BE_Inhabitant, inhab){
    NbInhabs++;
    if (inhab->GetManifestation()){
      NbManifesting++;
    }
}

if((NbManifesting / std::max(1, int(NbManifesting))) >= GetTresholdManifestation()){
    SetHasManifestationStreet(true);
}
else{
    SetHasManifestationStreet(false);
}
]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="CalcTruckCostTotal">
      <csm:CPPCode><![CDATA[float cost = GetTruckCostTotal();

csmForEachTypedSubEntity(BE_Truck, truck){
        cost+=truck->GetCostPerRoute();
  }
SetTruckCostTotal(cost);]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="CalcTrucksNeededAndActivate">
      <csm:CPPCode><![CDATA[
int activeTrucks = GetActiveTrucks();
int totalTrash = GetTotalTrash();
int volume = 0;
int lastFullness = 0;

csmForEachTypedSubEntity(BE_Truck, truck){
    volume=truck->GetVolume();
    if(truck->GetActive()){
        lastFullness+=truck->GetLastFullness();
        activeTrucks++;
    }
  }

float trucksNeeded = float((lastFullness+totalTrash))/float(volume);
//here it is important how to round.
if(fmod(trucksNeeded, 1.0) > GetEfficiantUsage()){
     trucksNeeded++;
}
activeTrucks = std::min(int(trucksNeeded), int(GetNbTrucks()));

SetActiveTrucks(activeTrucks);

//reset trucks
csmForEachTypedSubEntity(BE_Truck, truck){
    truck->SetActive(false);
}
//activate calculated amount trucks
csmForEachTypedSubEntity(BE_Truck, truck){
    if(activeTrucks > 0){
        truck->SetActive(true);
        activeTrucks--;
    }
}
]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="MesoPickupTrash">
      <csm:CPPCode><![CDATA[
RuleContext<EnvironmentType::RuleViewType>  ruleContext( GetModel<ProcessContext::ModelRuleViewType::ModelType>(), GetEnvironmentRuleView());

csmForEachTypedSubEntity(BE_Truck, truck){
    truck->R_PickupTrash(ruleContext);
}

csmForEachTypedSubEntity(BE_Inhabitant, inhab){
    inhab->Perceive(ruleContext);
}
csmForEachTypedSubEntity(BE_Inhabitant, inhab){
    inhab->React(ruleContext);
}
]]></csm:CPPCode>
    </csm:Process>
    <csm:Process name="MesoPerRct">
      <csm:CPPCode><![CDATA[RuleContext<EnvironmentType::RuleViewType>  ruleContext( GetModel<ProcessContext::ModelRuleViewType::ModelType>(), GetEnvironmentRuleView());

csmForEachTypedSubEntity(BE_Inhabitant, inhab){
    inhab->Perceive(ruleContext);
}
csmForEachTypedSubEntity(BE_Inhabitant, inhab){
    inhab->React(ruleContext);
}]]></csm:CPPCode>
    </csm:Process>
    <csm:State xsi:type="csm:CompositeType" name="StreetState">
      <csm:Container>
        <csm:Attribute name="TresholdManifestation" modifier="Parameter">
          <csm:DataTypeReference>FloatingPoint</csm:DataTypeReference>
          <csm:DefaultValue>0.05</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="TresholdTotalTrashPerInhab" modifier="Parameter">
          <csm:DataTypeReference>Integer</csm:DataTypeReference>
          <csm:DefaultValue>12</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="HasManifestationStreet" modifier="Variable">
          <csm:DataTypeReference>Boolean</csm:DataTypeReference>
          <csm:DefaultValue>false</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="TruckCostTotal" modifier="Variable">
          <csm:DataType xsi:type="csm:FloatType" name="Float_1" bits="32"/>
        </csm:Attribute>
        <csm:Attribute name="EfficiantUsage" modifier="Parameter">
          <csm:DataType xsi:type="csm:FloatType" name="Float_3" bits="32"/>
          <csm:DefaultValue>0.7</csm:DefaultValue>
        </csm:Attribute>
      </csm:Container>
    </csm:State>
    <csm:MesoFunction name="OverviewStreet">
      <csm:CPPCode><![CDATA[]]></csm:CPPCode>
      <csm:Operations>
        <csm:Operation xsi:type="csm:MesoSum" target="TotalTrash" subEntityAttribute="Bin"/>
        <csm:Operation xsi:type="csm:MesoValueCount" target="ActiveTrucks" subEntityAttribute="Active" attributeValue="true"/>
        <csm:Operation xsi:type="csm:MesoTypeCount" target="NbInhabitants" subEntityType="Inhabitant"/>
        <csm:Operation xsi:type="csm:MesoTypeCount" target="NbTrucks" subEntityType="Truck"/>
      </csm:Operations>
    </csm:MesoFunction>
    <csm:MesoState xsi:type="csm:CompositeType" name="StreetMesoState">
      <csm:Container>
        <csm:Attribute name="ActiveTrucks" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_13" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="TotalTrash" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_14" bits="32" signed="1"/>
        </csm:Attribute>
        <csm:Attribute name="NbInhabitants" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_2" bits="32" signed="1"/>
        </csm:Attribute>
        <csm:Attribute name="NbTrucks" modifier="Variable">
          <csm:DataType xsi:type="csm:IntType" name="Int_10" bits="32" signed="1"/>
          <csm:DefaultValue>0</csm:DefaultValue>
        </csm:Attribute>
        <csm:Attribute name="ActiveTrucksNeeded" modifier="Variable">
          <csm:DataType xsi:type="csm:FloatType" name="Float_4" bits="32"/>
        </csm:Attribute>
      </csm:Container>
    </csm:MesoState>
    <csm:Compound>
      <csm:Environment>Quartier</csm:Environment>
      <csm:SubEntities>
        <csm:CanBeWithin>Truck</csm:CanBeWithin>
        <csm:CanBeWithin>Inhabitant</csm:CanBeWithin>
      </csm:SubEntities>
    </csm:Compound>
  </csm:CompoundEntity>
  <csm:Environments>
    <csm:Communicator name="TruckToInhabitant">
      <csm:Documentation>Returns the new amount of litter in the bin
Inhabitant needs to updates its bin with
this value</csm:Documentation>
      <csm:CPPCode><![CDATA[return false;]]></csm:CPPCode>
      <csm:CommunicatedReference>Boolean</csm:CommunicatedReference>
      <csm:Destination>Inhabitant</csm:Destination>
      <csm:Source>Truck</csm:Source>
    </csm:Communicator>
    <csm:Communicator name="InhabitantToTruck">
      <csm:Documentation>The inhabitant passes the qmount of litter in the
bin to the truck
Request to empty the bin</csm:Documentation>
      <csm:CPPCode><![CDATA[return GetBin();]]></csm:CPPCode>
      <csm:CommunicatedReference>Integer</csm:CommunicatedReference>
      <csm:Destination>Truck</csm:Destination>
      <csm:Source>Inhabitant</csm:Source>
    </csm:Communicator>
    <csm:Communicator name="Chatter">
      <csm:CPPCode><![CDATA[return GetManifestation();
//if the sourrunding manifastates and the
//own agressivity is high, the start to manifest too.]]></csm:CPPCode>
      <csm:CommunicatedReference>Boolean</csm:CommunicatedReference>
      <csm:Destination>Inhabitant</csm:Destination>
      <csm:Source>Inhabitant</csm:Source>
    </csm:Communicator>
    <csm:Environment xsi:type="csm:NoEnvironment" name="NoEnvironment"/>
    <csm:Environment xsi:type="csm:Graph" name="Quartier">
      <csm:Edge name="Pickup">
        <csm:RightToLeftReference>TruckToInhabitant</csm:RightToLeftReference>
        <csm:LeftToRightReference>InhabitantToTruck</csm:LeftToRightReference>
      </csm:Edge>
      <csm:Edge name="Talk">
        <csm:RightToLeftReference>Chatter</csm:RightToLeftReference>
        <csm:LeftToRightReference>Chatter</csm:LeftToRightReference>
      </csm:Edge>
    </csm:Environment>
  </csm:Environments>
</csm:Model>
